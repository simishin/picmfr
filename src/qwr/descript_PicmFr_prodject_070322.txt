Новый проект на основе наработок проекта genPlan закончавшегося в 2021.
Проект начат 070322.
0) Создан по умолчанию, системные значения.
1) Локально создан, не известен вне.
2) Известен системе, НЕ используется локально.
3) Известен системе, Используется локально и ВНЕ, синхронизован.
4) Внешняя Блокировка с рассинхронизацией
(жду изменений и после корректировке (5-4) возврат к 4)
5) Блокирован локально или рассинхронизован.(показываю что начал изменения,
после всех внешних 5, возвращаюсь к 4)
6) Используется локально, но устарел локально и ВНЕ (переход с 6-7 локально или 5-7 внешнее)
7) НЕ используется и Устарел локально и Пока ВНЕ используется
таблица переходов (начальное состояние - конечное : условие)
0-х : неизменяемый элемент
--1 : создание элемента в локальной базе
--2 : элемент получен из внешней базы
1-3 : локальный элемент обнаружен хотя бы в одной внешней базе
2-3 : внешний элемент применен в локальной базе, если нет флага устаревший (4,5,6,7)
3-4 : во внешней базе состояние элемента изменилось с 3-5 и запрет работы с элементом
4-3 : во внешней базе состояние элемента изменилось с 5-3 и принята коррекция полей
4-6 : внешне элемент помечен как устаревший (6 или 7) и дальнейшее назначение его запрещено
6-7 : устаревший элемент перестал использоваться в локальной базе
7-х : во всех внешних базах помечен как (7) или отсутствует. Элемент удален из лок. базы
3-5 : элемент взят на корректировку локально при наличии соответствующих прав
5-3 : во всех синхронизованных базах элемент помечен (4). Записываю изменения в лок. базу
5-6 : помечаю элемент как устарел и записываю в базу, но еще используется локально.
6-5 : элемент взят на корректировку локально при наличии соответствующих прав
5-7 : помечаю элемент как устарел и записываю в базу, и Не используется локально.
3-2 : элемент перестал использоваться локально
1-2 : элемент зарегистрирован хотя бы в одной внешней базе, но локально не используется
3-6 : элемент помечен хотя бы в одной базе как устаревший (6 или 7), но используется локально
2-7 : элемент помечен хотя бы в одной базе как устаревший (6 или 7) и не используется локально
1-7 : элемент создан по ошибке и сразу удален.
5-4 : элемент отдан администратору. Ожидает во внешней базе (5) ??????
4-5 : элемент принят от другого. контроль ключа хозяина ??????
Учитывая, что в одной переменой находятся состояния элементов внешних баз код может быть:
 1  бит Р - 1-используется
 2  бит A - 1-блокирован локально
 4  бит И - 1-устарел
 0000 00  не известен
 0001 01  присутствует в базе
 0010 02  используется в базе
 0011 03  блокирован локально
 0100 04  удален из локальной базы
 0101 05  устарел и не используется
 0110 06  устарел и используется
 0111 07  внешнее блокирование (дублорование значений полей внешних баз)
 Расчет времени с с 1 января 1970г.
 int = 4 байта = 2147483647c = 35791394 минут= 596523 часов = 24855 дней = 65 лет
       3 байта= ffffff = 16777215с=194,дней; 2 байта = 32767дней = 89 лет
       итого в день создают 4 проекта = 22 года; элементы создаются каждые пол секунды.
       точка отсчета 2020г.
 Формирую ключ элемента из секунд создания (int), кода проекта в днях (shor),
 кода принадлежности к структуре(byte), код создателя(byte) =
 long = + byte + byte + short + int
 short flags |4443.3322.2111.000g| где G=1 если группирующая запись

 1  бит Р - 1-используется
 2  бит A - 1-блокирован локально
    бит -устарел заменен на отличное от 0 значение нового ключа
 0000 00  не известен
 0001 01  присутствует в базе
 0010 02  используется в базе
 0011 03  блокирован локально








--------------------------------------------------------------------------------------------------------
 short flags |6655.4433.2211.00хg| где G=1 если группирующая запись
                                       Х=1 внешнее блокирование (дублорование)
 abstract class BaseElement {//Guid=справочник,руководство
     private static int  count=0;//cчетчик для элементов по умолчанию
     protected int       key;    //1) время создания в секундах с 1 января 1970г.(ключ)
//     protected int       union;  //2) ссылка на объединение
     protected String    titul;  //3) наименование (*)
     protected String    descr;  //4) описание (*)
     protected short     owner;  //5) идентификатор пользователя создавшего
//     protected int       hasp;   //6) контрольная сумма с 1 по 5 параметры
     protected short     flags;  //7) флаги/статус/состояние
     protected int       link;   //8) ссылка на новый ключ
     protected int       order;  //9) порядок следования внутри группы

 abstract class UserElement extends BaseElement {

class EiPath extends BaseElement {
    public static final int sizeAr=8;//количество полей в текстовом файле данных


+*--class EjAuthor extends GeneralElement implements InterfaceElement
 !
 !  *--abstract class AlternativeElement implements InterfaceElement
 !  !    String    title;  //наименование элемента
 !  !    String    alias;  //альтернативное название
 V  V
public interface InterfaceElement

 abstract class BaseElement {//Guid=справочник,руководство
     private static int  count=0;//cчетчик для элементов по умолчанию
     protected long      key;    //1) время создания в секундах с 1 января 1970г.(ключ)
     protected String    titul;  //3) наименование (*)
     protected String    descr;  //4) описание (*)
     protected short     flags;  //5) флаги/статус/состояние
     protected long      link;   //6) ссылка на новый ключ
     protected short     order;  //7) порядок следования внутри группы

 Формирую ключ элемента (k) из секунд создания (int), кода проекта (p) в днях (shor),
 кода принадлежности (s) к структуре(byte), код создателя(u)(byte) =
 long = + byte + byte + short + int
 long = ss.pp.pp.uu.kk.kk.kk.kK
 long = uu.uu.Uk.kk.kk.kk.kc.cc
 c=4095; 2 байта = 32767дней = 89 лет> 15bit=44jar
 63 bit=32+13 код записи + 4+ 14 код пользователя
 14 бит= 16383 дня = 45лет
 13 бит= 8191 запись в секунду
 int=4  294 967 295 сек= 497102 дней = 1361 год
 1361 год /32 =42,5 лет = -5 бит
 63 бит = код записи ((31-5)+12)+код пользователя (14+4) + код структуры (7)

     public static void printList(){
         prnq("Список проектов из :"+list.size());
         for (RiProdject x:list) prnq(x.order+" \t"+x.name+" \t["+x.flag+"] \t"+
                 x.titul+" \t"+x.create+ " \t"+x.fileCfg+" \t{"+x.descr+"}");
         prnq("___________");
     }//printList

160422==============================================================================
Проблема: при подгрузке файлов конфигурации из командной строки теряется путь при 
совпадении времени создания (create) и идентификатора проекта (name) - дублирование.

ЛОкализую функционал: убираю временные переменные tmpDescr и tmpTitul из класса 
RiProdject в процедуру обработки FileType.loadScan.

Заголовок TITUL каждого файла состоит из RiProdject.getCurName(), 
RiProdject.getCurCreat(), RiProdject.getCurTitul(), а файл конфигурации дополнительно
включает поле DESCR-строку описания проекта

RiProdject состоит из динамических значений:
create;  //+дата создания проекта
change;  //+дата последнего изменения конфигурации (либо дата файла либо ???)
order;   //порядок следования в списке (получаемые из командной строки - к конец)
flag;    //количество синхронизируемых зеркал (из командной строки = 0 ),
name;    //+код проекта
titul;   //+наименование
descr;   //+описание
fileCfg; //+путь к файлу конфигурации
190422===================================================================================
Поправил метод до FileType:public  boolean save(){ return save(pach); }
Проблема: файл конфигурации не читается из-за несоответствия формата.
ищу способ создания новых файлов конфигурации.
Смотрю на результат анализа командной строки RiProdject.addCfgFromComStr #231
и добавляю функционал

280422==================================================================================
Возвращаюсь к системе кодирования, формирования ключей записей в базе данных
Что было:
63 бит = код записи ((31-5)+12)+код пользователя (14+4) + код структуры (7)
long = uu.uu.Uk.kk.kk.kk.kc.cc
(k) из секунд создания (int) =8*4=32бит=целое,
 кода принадлежности (с) к структуре(byte)=3*4=12бит=4095 вариантов,
 код создателя(u)
 Задача: обеспечить уникальность кода записи при одновременном
 не синхронизованном вводе данных.
 Для этого использую код пользователя, по скольку не может быть 2х логинов одновременно.
 Вторая часть - это счетчик. Возможно совмещение с временем создания.
 Принадлежность к проекту и структуре данных обеспечивается точной/местом создания.

 Уникальность кода пользователя может быть обеспечена комбинацией кода
 проекта, где впервые появился пользователь и временем его создания.

 Код проекта определяется временим его создания.
 Если точка отсчета: 2021-01-15T00:03 = 1610643835L
 Цикл повторяемости проектов 33 года и  они создаются раз в час = 289080=0х46938
 0x3FFFF=262143=повторяемость 29,9 лет  при ежечасовом создании проекта
 тогда под пользователя остается:
 0x3FFF=16383 секунд = повторяемость 4.55 часа
 16383 дней = повтряемость 44.88 лет или при часах 1.87 лет
 1 день = 24*60*60=86400 секунд. Ближайшее минимальное 0xFFFF=65535=сдвиг на 16 бит
 
 Генератор ключей реализован в классе   PublStat
 
